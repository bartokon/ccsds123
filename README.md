# CCSDS-123 Reference Codec

This repository provides a C++20 reference port of the CCSDS 123.0-B-2 lossless
pipeline. The implementation targets CPU builds and serves as the scalar path for
AMD Versal AI Engine kernels. The current milestone covers RGB imagery (three bands
in BSQ layout) with narrow neighbour-oriented local sums and the sample-adaptive
Golomb entropy coder.

## Design highlights

### Repository layout

The sources are grouped under `src/` to keep host, HDL, and AI Engine
implementations co-located:

- `src/cpp` — C++ library, command-line tools, headers, and unit tests.
- `src/hdl` — VHDL sources, test benches, and Vivado automation scripts.
- `src/aie` — AI Engine kernels and graph definitions.
- `src/python_reference` — Reference Python implementations used to generate
  shared verification vectors.
- `tests/data` — Reusable fixtures shared across the host and hardware flows.

- **One-to-one module ports:** the control, local-difference, dot-product,
  predictor, weight-update, and residual-mapper VHDL units are translated directly
  into `ccsds123::modules`. Each function mirrors the original fixed-point
  arithmetic, mod-2\(^R\) accumulator, Θ computation, and parity-dependent mapping
  logic so the C++ pipeline matches the HDL cycle-by-cycle.
- **Stateful predictor:** adaptive weights are initialised as in the Blue Book,
  updated with the CCSDS scaling exponent schedule, and applied to the directional
  local differences. The predictor produces the scaled sample (2ŝ), enabling the
  residual mapper to follow Section 5.4.3 exactly.
- **Sample-adaptive coder:** the scalar path now mirrors the HDL configuration
  used in `tools/conf.json` with \(U_{\max} = 18\), a six-bit counter, initial
  count exponent of one, and \(K'_z = 0\). The unary/binary Golomb mapping and
  accumulator updates match the VHDL implementation bit-for-bit, ensuring payload
  identity between the software and hardware flows.
- **Container:** a versioned little-endian header (magic `C123`) precedes the
  bit payload. Dimensions, predictor order, local-sum mode, coder flags, and
  payload length are embedded for decoder validation. Version 3 headers also
  capture the weight-update and sample-adaptive coder parameters so tools can
  round-trip containers without external configuration files.
- **AIE integration:** `aie/aie_kernel.cc` offers fixed-size wrappers that call the
  library without dynamic allocation, exceptions, or RTTI inside kernels, matching
  the Vitis AI Engine compilation constraints.

## Building

```bash
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release
cmake --build build -j
```

The build generates:

- `libccsds123` — static library
- `ccsds123_encode` / `ccsds123_decode` — CLI tools
- `ccsds123_tests` — Catch2 regression suite

## Testing

```bash
ctest --test-dir build -V
```

Unit tests cover RGB round-trips, random fixed-seed imagery, and the control
module’s scan order. Additional regression tests verify encoding into external
bitstream buffers, container summaries, and the behaviour of the predictor,
weight-update, and dot-product helpers. A shared CSV of local-difference
stimuli, generated by the Python reference model, keeps the C++ module locked to
the HDL behaviour.

## HDL regression flows

The behavioural test bench consumes an 8×8×3 gradient stimulus generated from
`tools/conf.json`. Invoke `make hdl-sim` to regenerate the implementation
parameters, launch Vivado in batch mode, and stream the shared test vector
through the HDL compressor. The test bench writes the payload to
`build/vectors/hdl/out.bin` and prints the observed compression ratio and stall
metrics to the console.

`make compare` extends the flow by compiling the C++ reference, encoding the same
gradient, and running `tools/compare_bitstreams.py`. The helper strips the C++
container header, compares the payload bits against the HDL dump, and reports the
compression ratio using the shared input size. A matching payload confirms that
the hardware path and the software codec remain in lock-step.

`tools/hdl_compare.py` stays available for reconstructed-image comparisons once a
decoded dump is produced.

## Vivado automation

The `make hdl-project` and `make hdl-sim` targets now check that the Verilog and
VHDL parameter include files exist before Vivado starts. Regenerate them with
`make hdl-params`. By default the parameters are derived from `tools/conf.json`;
set the `HDL_CONFIG` environment variable to point at an alternative
configuration if required.

## Command-line tools

Encoding raw BSQ (`u16le`) data:

```bash
python3 - <<'PY' > /tmp/rgb8x8_u16le.bsq
from itertools import product
out = bytearray()
for z in range(3):
    for y in range(8):
        for x in range(8):
            val = (x * 5 + y * 3 + z * 11) & 0xFF
            out += val.to_bytes(2, 'little')
open('/tmp/rgb8x8_u16le.bsq', 'wb').write(out)
PY
./build/ccsds123_encode -i /tmp/rgb8x8_u16le.bsq -o out.bin -nx 8 -ny 8 -nz 3 -d 8
```

Decoding back to BSQ:

```bash
./build/ccsds123_decode -i out.bin -o recon.bsq
```

`ccsds123_encode` also accepts binary PPM (`P6`) input via `--ppm`, inferring the
resolution from the header. When the input path is a directory the tool scans all
regular files, compressing each frame into an output directory (creating
`frame_XXXX.c123` alongside the originals). Decoding mirrors this behaviour: a
directory of `.c123` containers expands into BSQ frames using the stored
dimensions.

Synthetic multi-channel fixtures can be generated with
`tools/generate_frames.py`. The script produces deterministic four-channel BSQ
frames that exercise the CCSDS-123 pipeline:

```bash
python3 tools/generate_frames.py --frames 1 --nx 10 --ny 6 --nz 4 --output-dir tests/data
./build/ccsds123_encode -i tests/data/frame_0001.bsq -o out/frame_0001.c123 -nx 10 -ny 6 -nz 4 -d 16
./build/ccsds123_decode -i out/frame_0001.c123 -o out/frame_0001.bsq
```

The generated frame is reused by the unit tests to verify lossless round-trips
for four-channel imagery.

## HDL comparison script

`tools/hdl_compare.py` compares reconstructed pixels or predictor residuals against
files produced by the HDL environment. Example usage once an HDL dump is available:

```bash
python3 tools/hdl_compare.py --nx 8 --ny 8 --nz 3 --depth 16 \
    --reference build/rgb8x8_u16le.bsq \
    --hdl-recon path/to/hdl_reconstructed.bsq \
    --hdl-residuals path/to/hdl_residuals.txt
```

The script reports coordinate-labelled mismatches (first 20) and length
inconsistencies.

## Notes on parameter choices

- **Narrow neighbour sums:** eliminate direct left-sample dependencies while
  matching CCSDS Section 3.4.3, easing AIE pipelining.
- **Predictor order \(P = 0\):** RGB uses intra-band prediction for this milestone;
  previous-band taps and near-lossless quantisation knobs are staged for follow-up
  work.
- **Θ, ϕ, ψ, aᵢ, rᵢ:** zeroed so the quantiser acts as an identity for lossless
  validation.

Future milestones will extend the library with near-lossless modes, the hybrid
coder, Issue-1 compatibility switches, and vectorised AIE paths.
