# CCSDS 123 Reference Implementation

A multi-platform implementation of the CCSDS 123.0-B-2 lossless image compression standard, targeting C++, VHDL hardware description, and AMD-Xilinx AI Engine kernels.

## Project Structure

- `src/cpp/` — C++ codec library and CLI tools
- `src/hdl/` — VHDL compressor and test bench
- `src/aie/` — AI Engine kernels and graph definitions
- `tools/` — Build automation and regression scripts
- `docs/` — Architecture notes and design documentation

## Building

CMake drives the C++ build; the Makefile orchestrates HDL simulation and cross-platform regression tests.

```bash
make cpp
```

This compiles the C++ codec, runs unit tests, and produces:
- `ccsds123_encode` / `ccsds123_decode` — CLI tools
- `ccsds123_tests` — Catch2 regression suite

## Testing

```bash
ctest --test-dir build -V
```

Unit tests cover RGB round-trips, random fixed-seed imagery, and the control module's scan order. Additional regression tests verify encoding into external bitstream buffers, container summaries, and the behaviour of the predictor, weight-update, and dot-product helpers. A shared CSV of local-difference stimuli, generated by the Python reference model, keeps the C++ module locked to the HDL behaviour.

## HDL regression flows

The behavioural test bench consumes an 8×8×3 gradient stimulus generated from `tools/conf.json`. Invoke `make hdl-sim` to regenerate the implementation parameters, launch Vivado in batch mode, and stream the shared test vector through the HDL compressor. The test bench writes the payload to `build/vectors/hdl/out.bin` and prints the observed compression ratio and stall metrics to the console.

`make compare` extends the flow by compiling the C++ reference, encoding the same gradient, and running `tools/compare_bitstreams.py`. The helper strips the C++ container header, compares the payload bits against the HDL dump, and reports the compression ratio using the shared input size. The behavioural test bench now pre-loads the BSQ input cube and feeds the DUT with band-interleaved (BIP) samples, mirroring the control logic inside the compressor. A matching payload confirms that the hardware path and the software codec remain in lock-step. A synthesizable input re-ordering stage will follow in a future milestone so that board-level designs can accept BSQ streams directly.

`make run_compare` extends the flow by running the C++ unit tests, compiling the reference codec, executing the Vivado simulation, and finally invoking `tools/compare_bitstreams.py`. The helper now exports the C++ payload, compares the payload bits against the HDL dump with byte- and bit-level diagnostics, and decodes both bitstreams to confirm lossless round-trips before reporting the shared compression ratio. The behavioural test bench pre-loads the BSQ input cube and feeds the DUT with band-interleaved (BIP) samples, mirroring the control logic inside the compressor. A matching payload confirms that the hardware path and the software codec remain in lock-step. A synthesizable input re-ordering stage will follow in a future milestone so that board-level designs can accept BSQ streams directly.

`tools/hdl_compare.py` stays available for reconstructed-image comparisons once a decoded dump is produced.

## Video compression testing (Alternative 1)

The project includes Makefile targets for testing video compression using the Alternative 1 approach described in [Barrios et al., 2022](docs/Adaptation_of_the_CCSDS_123.0-B-2_Standard_for_RGB_Video_Compression.txt), where temporal frames replace spectral bands. Each RGB color channel is treated as an independent temporal sequence.

### Single-frame test (quick validation)

```bash
make run_compare_video_single
```

Processes the first frame from `data/128x128/`, splitting RGB into three independent channels (R, G, B). Each channel is compressed separately using the CCSDS 123 codec with dimensions NX=128, NY=128, NZ=1 (1 temporal "band"). Both HDL and C++ implementations are verified to produce matching payloads, and per-channel compression ratios are reported.

### Full 10-frame test

```bash
make run_compare_video
```

Processes all 10 frames from `data/128x128/`, concatenating them temporally into three channel sequences with NZ=10 (10 temporal "bands" per channel). The test verifies HDL/C++ implementation agreement and reports aggregate compression statistics for all three channels.

**Note**: The current implementation uses `P=0` (no inter-band prediction). Both HDL and C++ configurations must use matching P values. The C++ encoder currently hardcodes `P=0` and does not support `P>0` modes.

Expected compression ratios for natural imagery range from 2.0–4.0:1, compared to ~3.6:1 for the synthetic gradient test pattern.

### Known Behavior: HDL Payload Size Differences

The HDL implementation produces slightly larger compressed payloads than the C++ version due to bitstream packing differences:

- **Algorithm**: Both use the identical sample-adaptive Golomb encoder (CCSDS 123 section 5.4.3.2)
- **Packing**: HDL uses word-aligned (32-bit) packing for AXI-Stream protocol compliance
- **Impact**: HDL output is typically 10-15% larger due to word-boundary padding
- **Lossless**: Both implementations decode correctly and produce identical reconstructed images

This behavior is expected and documented in [docs/hdl_cpp_encoder_comparison.md](docs/hdl_cpp_encoder_comparison.md). The size difference does not indicate a compression quality issue—both implementations meet CCSDS 123.0-B-2 compliance.

## Vivado automation

The `make hdl-project` and `make hdl-sim` targets now check that the Verilog and VHDL parameter include files exist before Vivado starts. Regenerate them with `make hdl-params`. By default the parameters are derived from `tools/conf.json`; set the `HDL_CONFIG` environment variable to point at an alternative configuration if required.

## Command-line tools

Encoding raw BSQ (`u16le`) data:

```bash
python3 - <<'PY' > /tmp/rgb8x8_u16le.bsq
from itertools import product
out = bytearray()
for z in range(3):
    for y in range(8):
        for x in range(8):
            val = (x * 5 + y * 3 + z * 11) & 0xFF
            out += val.to_bytes(2, 'little')
open('/tmp/rgb8x8_u16le.bsq', 'wb').write(out)
PY

build/src/cpp/ccsds123_encode \
  -i /tmp/rgb8x8_u16le.bsq \
  -o /tmp/out.c123 \
  -nx 8 -ny 8 -nz 3 -d 16
```

Decoding:

```bash
build/src/cpp/ccsds123_decode \
  -i /tmp/out.c123 \
  -o /tmp/decoded_u16le.bsq
```

Use `cmp` or `diff` to verify that `/tmp/decoded_u16le.bsq` matches the original `/tmp/rgb8x8_u16le.bsq`.

## License

See LICENSE for details.
